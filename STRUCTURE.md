# Структура проекта и Best Practices

В этом документе подробно описано назначение каждой директории в `src/` и правила работы с ними в рамках нашей архитектуры (Production-Ready Next.js 15).

## `src/`

Корневая директория исходного кода. Использование `src` позволяет отделить конфигурационные файлы (`package.json`, `next.config.ts`, `tsconfig.json` и т.д.) от логики приложения.

### 1. `/app` (App Router)
Здесь располагается **файловая маршрутизация** Next.js.
*   **Best Practices**:
    *   **Минимум логики**: Страницы (`page.tsx`) должны быть максимально "тонкими". Они отвечают за получение данных (Server Side Fetching) и передачу их в компоненты.
    *   **Server Components по умолчанию**: Старайтесь оставлять компоненты серверными (RSC), пока не потребуется интерактивность (`use client`).
    *   **Colocation**: Файлы, специфичные *только* для конкретного маршрута (например, локальные компоненты или утилиты), можно держать рядом с `page.tsx`.

### 2. `/components`
Компоненты делятся по уровню ответственности (частично вдохновлено Atomic Design и Feature-Sliced Design).

#### `/components/ui` (Atomic / Dumb Components)
Базовые, переиспользуемые UI-элементы без бизнес-логики.
*   **Примеры**: `Button`, `Input`, `Modal`, `Card`, `Typography`.
*   **Правила**:
    *   Не должны импортировать `store` или `services`.
    *   Принимают все данные только через `props`.
    *   Легко тестируются и визуализируются в Storybook.

#### `/components/common` (Shared Structure)
Компоненты, определяющие общую структуру страниц или глобальные элементы.
*   **Примеры**: `Header`, `Footer`, `Sidebar`, `Breadcrumbs`, `Navigation`.
*   **Правила**: Могут содержать минимальную логику навигации, но не сложную бизнес-логику.

#### `/components/features` (Smart / Business Components)
Компоненты, реализующие конкретную функциональность или бизнес-сценарий.
*   **Примеры**: `UserRegistrationForm`, `TrackerWidget`, `ChatWindow`, `ProductList`.
*   **Правила**:
    *   Могут взаимодействовать со `store` (Zustand) и `hooks`.
    *   Собирают внутри себя `ui` компоненты.
    *   Обычно являются Client Components (`'use client'`).

### 3. `/services`
Слой взаимодействия с внешним миром (API).
*   **Содержимое**:
    *   `api.ts`: Сконфигурированный инстанс Axios (interceptors, base URL).
    *   `auth.service.ts`, `user.service.ts`: Функции для конкретных запросов.
*   **Best Practices**:
    *   Компоненты **не должны** вызывать `axios.get` напрямую. Они должны вызывать методы сервисов (например, `UserService.getProfile()`).
    *   Это упрощает рефакторинг API и мокирование тестов.

### 4. `/store` (State Management)
Глобальное состояние приложения на базе **Zustand**.
*   **Подход**: Делим сторы по доменам.
    *   `store/user.ts`: Данные сессии, профиль, авторизация.
    *   `store/ui.ts`: Открытие модалок, темы, сайдбары.
    *   `store/tracker.ts`: Данные трекера.
*   **Best Practices**: Держите сторы атомарными. Не создавайте один гигантский `useStore`.

### 5. `/styles` (Global Styling)
Глобальные стили и SCSS утилиты.
*   `globals.scss`: Сброс стилей, шрифты, базовые настройки `body`.
*   `_variables.scss`: Цветовая палитра, размеры шрифтов, брейкпоинты.
*   `_mixins.scss`: Переиспользуемые сниппеты CSS (Flexbox центрирование, медиа-запросы).
*   **Правила**: Компоненты используют CSS Modules (`*.module.scss`), но импортируют переменные и миксины из этой папки.

### 6. `/types` (TypeScript Definitions)
Общие типы данных, используемые в разных частях приложения.
*   **Содержимое**:
    *   DTO (Data Transfer Objects) — типы ответов от бэкенда.
    *   Интерфейсы сущностей (`User`, `Product`).
    *   Глобальные Enum.
*   **Зачем**: Чтобы не дублировать интерфейс `User` в компоненте, в сторе и в сервисе.

### 7. `/hooks` (Custom Hooks)
Выделенная логика React.
*   **Примеры**: `useOnClickOutside`, `useWindowSize`, `useAuth`, `useDebounce`.
*   **Best Practices**: Если логика внутри `useEffect` занимает больше 5-10 строк или используется в двух местах — выносите в хук.

---

### Резюме потока данных (Data Flow)
1.  **Page (`/app`)** запрашивает данные (если SSR) или рендерит Feature Component.
2.  **Feature Component (`/components/features`)** подключает **Store (`/store`)** или **Hook (`/hooks`)**.
3.  **Store/Hook** использует **Service (`/services`)** для запроса к API.
4.  **Service** использует **Axios Instance** и возвращает типизированный ответ (**DTO из `/types`**).
5.  Данные текут вниз в **UI Components (`/components/ui`)** через пропсы.
